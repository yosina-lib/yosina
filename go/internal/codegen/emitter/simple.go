package emitter

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"go/format"
	"path"
	"strings"
	"text/template"

	"github.com/alecthomas/mph"
	yosina "github.com/yosina-lib/yosina/go"
	"github.com/yosina-lib/yosina/go/internal/codegen/data"
)

// Templates for code generation
const simpleTransliteratorTemplate = `// Code generated by codegen. DO NOT EDIT.
package {{.Name}}

import (
	_ "embed"
	"encoding/binary"

	"github.com/alecthomas/mph"

	yosina "github.com/yosina-lib/yosina/go"
)

//go:embed data.bin
var data []byte

var mapping *mph.CHD

func init() {
	var err error
	mapping, err = mph.Mmap(data)
	if err != nil {
		panic(err)
	}
}

type simpleCharIterator struct {
	yosina.CharIterator
	offset int
}

func (i *simpleCharIterator) Next() *yosina.Char {
	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	if c.IsSentinel() {
		return c
	}
	// Check if current character can be transliterated
	var k [8]byte
	binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
	binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))
	if v := mapping.Get(k[:]); v != nil {
		cc := [2]rune{yosina.InvalidUnicodeValue, yosina.InvalidUnicodeValue}
		if len(v) >= 4 {
			cc[0] = rune(binary.LittleEndian.Uint32(v[:4]))
		}
		if len(v) >= 8 {
			cc[1] = rune(binary.LittleEndian.Uint32(v[4:]))
		}
		c = &yosina.Char{
			C: cc,
			Offset: i.offset,
			Source: c,
		}
	} else {
		c = c.WithOffset(i.offset)
	}
	i.offset += c.RuneLen()
	return c
}

func Transliterate(i yosina.CharIterator) yosina.CharIterator {
	return &simpleCharIterator{i, 0}
}
`

func (em *Emitter) GenerateSimpleTransliterator(name string, data map[data.UCodepoint]data.UCodepoint) ([]Artifact, error) {
	// Convert data to string-to-string mappings
	tmpl, err := template.New("simple").Parse(simpleTransliteratorTemplate)
	if err != nil {
		return nil, err
	}

	var buf strings.Builder
	err = tmpl.Execute(&buf, map[string]interface{}{
		"Name":     name,
		"Mappings": data,
	})
	if err != nil {
		return nil, err
	}

	b := mph.Builder()
	for k, v := range data {
		var buf [12]byte
		binary.LittleEndian.PutUint32(buf[0:4], uint32(k))
		binary.LittleEndian.PutUint32(buf[4:8], uint32(yosina.InvalidUnicodeValue))
		binary.LittleEndian.PutUint32(buf[8:12], uint32(v))
		b.Add(buf[0:8], buf[8:])
	}
	// Format the generated code
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w", err)
	}
	d, err := b.Build()
	if err != nil {
		return nil, fmt.Errorf("failed to build mph: %w", err)
	}
	var bb bytes.Buffer
	d.Write(&bb)
	return []Artifact{
		{
			Filename: path.Join(name, "impl.go"),
			Content:  formatted,
		},
		{
			Filename: path.Join(name, "data.bin"),
			Content:  bb.Bytes(),
		},
	}, nil
}

func (em *Emitter) GenerateKanjiOldNewTransliterator(name string, mappings map[data.UCodepointTuple]data.UCodepointTuple) ([]Artifact, error) {
	// Convert UCodepointTuple mappings to UCodepoint mappings for simple transliterator
	// This assumes that most kanji old-new mappings are single codepoint to single codepoint
	simpleData := make(map[data.UCodepoint]data.UCodepoint)

	for from, to := range mappings {
		// Handle the common case where both from and to are single codepoints
		if from[1] == data.InvalidValue && to[1] == data.InvalidValue {
			simpleData[from[0]] = to[0]
		}
		// For multi-codepoint sequences, we could extend the simple transliterator
		// or create a more complex one. For now, skip these cases.
	}

	return em.GenerateSimpleTransliterator(name, simpleData)
}
