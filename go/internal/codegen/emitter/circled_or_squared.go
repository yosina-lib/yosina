package emitter

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"go/format"
	"strings"
	"text/template"

	"github.com/alecthomas/mph"
	"github.com/yosina-lib/yosina/go/internal/codegen/data"
)

const circledOrSquaredTransliteratorTemplate = `// Code generated by codegen. DO NOT EDIT.
package {{.Name}}

import (
	_ "embed"
	"encoding/binary"
	"strings"

	"github.com/alecthomas/mph"

	yosina "github.com/yosina-lib/yosina/go"
)

//go:embed data.bin
var data []byte

var mapping *mph.CHD

func init() {
	var err error
	mapping, err = mph.Mmap(data)
	if err != nil {
		panic(err)
	}
}

// Options for the circled or squared transliterator
type Options struct {
	TemplateForCircled string
	TemplateForSquared string
	IncludeEmojis      bool
}

type circledOrSquaredCharIterator struct {
	yosina.CharIterator
	offset int
	queue  []rune
	source *yosina.Char
	options Options
}

func (i *circledOrSquaredCharIterator) Next() *yosina.Char {
	// If we have queued characters from a previous expansion, return them first
	if len(i.queue) > 0 {
		c := i.queue[0]
		i.queue = i.queue[1:]
		char := &yosina.Char{
			C:      [2]rune{c, yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: i.source,
		}
		i.offset += char.RuneLen()
		return char
	}

	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	if c.IsSentinel() {
		return c
	}

	// Check if current character can be transliterated
	var k [8]byte
	binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
	binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))
	if v := mapping.Get(k[:]); v != nil {
		// Decode the record from the value
		if len(v) < 5 {
			// Invalid data, return original character
			return c.WithOffset(i.offset)
		}

		renderingLen := int(v[0] & 0xf)
		typeCode := v[0] & 0x10
		isEmoji := v[0] & 0x20 != 0

		// Skip emoji characters if not included
		if isEmoji && !i.options.IncludeEmojis {
			char := c.WithOffset(i.offset)
			i.offset += char.RuneLen()
			return char
		}

		// Extract rendering string (UTF-32 encoded)
		var r strings.Builder
		for j := 0; j < renderingLen; j++ {
			r.WriteRune(rune(binary.LittleEndian.Uint32(v[1+j*4:])))
		}
		rendering := r.String()

		// Determine template
		var template string
		if typeCode == 0 { // circle
			template = i.options.TemplateForCircled
		} else { // square
			template = i.options.TemplateForSquared
		}

		// Apply template
		replacement := strings.ReplaceAll(template, "?", rendering)
		replacementRunes := []rune(replacement)

		if len(replacementRunes) == 0 {
			// No replacement, return original
			char := c.WithOffset(i.offset)
			i.offset += char.RuneLen()
			return char
		}

		// Store the source for all subsequent characters
		i.source = c

		// Return the first character immediately
		firstChar := &yosina.Char{
			C:      [2]rune{replacementRunes[0], yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: c,
		}
		i.offset += firstChar.RuneLen()

		// Queue the remaining characters
		if len(replacementRunes) > 1 {
			i.queue = replacementRunes[1:]
		}

		return firstChar
	} else {
		char := c.WithOffset(i.offset)
		i.offset += char.RuneLen()
		return char
	}
}

func Transliterate(i yosina.CharIterator, options Options) yosina.CharIterator {
	if options.TemplateForCircled == "" {
		options.TemplateForCircled = "(?)"
	}
	if options.TemplateForSquared == "" {
		options.TemplateForSquared = "[?]"
	}
	return &circledOrSquaredCharIterator{CharIterator: i, offset: 0, options: options}
}
`

func (em *Emitter) GenerateCircledOrSquaredTransliterator(name string, mappings map[data.UCodepoint]data.CircledOrSquaredRecord) ([]Artifact, error) {
	tmpl, err := template.New("circled_or_squared").Parse(circledOrSquaredTransliteratorTemplate)
	if err != nil {
		return nil, err
	}

	var buf strings.Builder
	err = tmpl.Execute(&buf, map[string]interface{}{
		"Name": name,
	})
	if err != nil {
		return nil, err
	}

	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format Go source: %w", err)
	}

	// Generate binary data for the mappings
	binaryData, err := generateCircledOrSquaredBinaryData(mappings)
	if err != nil {
		return nil, fmt.Errorf("failed to generate binary data: %w", err)
	}

	return []Artifact{
		{
			Filename: name + "/impl.go",
			Content:  formatted,
		},
		{
			Filename: name + "/data.bin",
			Content:  binaryData,
		},
	}, nil
}

func generateCircledOrSquaredBinaryData(mappings map[data.UCodepoint]data.CircledOrSquaredRecord) ([]byte, error) {
	// Build the perfect hash table using the mph.Builder pattern
	b := mph.Builder()

	for char, record := range mappings {
		// Create key (8 bytes for UCodepoint tuple)
		key := make([]byte, 8)
		binary.LittleEndian.PutUint32(key[:4], uint32(char))
		binary.LittleEndian.PutUint32(key[4:], uint32(data.InvalidValue)) // Second rune is invalid for single chars

		// Create value (4 bytes rendering length + 4 bytes type + 4 bytes emoji flag + rendering data)
		renderingRunes := []rune(record.Rendering)
		value := make([]byte, 1+len(renderingRunes)*4)

		// Store rendering length

		// Store type (0 for circle, 1 for square)
		var typeCode uint8
		switch record.Type {
		case "circle":
			typeCode = 0
		case "square":
			typeCode = 0x10
		default:
			return nil, fmt.Errorf("unknown type: %s", record.Type)
		}

		// Store emoji flag
		var emojiFlag uint8
		if record.Emoji {
			emojiFlag = 0x20
		}
		value[0] = uint8(len(renderingRunes)) | typeCode | emojiFlag

		// Store rendering characters (UTF-32)
		for i, r := range renderingRunes {
			binary.LittleEndian.PutUint32(value[1+i*4:], uint32(r))
		}

		b.Add(key, value)
	}

	// Build the perfect hash table
	table, err := b.Build()
	if err != nil {
		return nil, fmt.Errorf("failed to build perfect hash table: %w", err)
	}

	// Serialize to bytes
	var buf bytes.Buffer
	if err := table.Write(&buf); err != nil {
		return nil, fmt.Errorf("failed to serialize hash table: %w", err)
	}

	return buf.Bytes(), nil
}
