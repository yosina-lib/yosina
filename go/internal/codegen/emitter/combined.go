package emitter

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"go/format"
	"strings"
	"text/template"

	"github.com/alecthomas/mph"
	"github.com/yosina-lib/yosina/go/internal/codegen/data"
)

const combinedTransliteratorTemplate = `// Code generated by codegen. DO NOT EDIT.
package {{.Name}}

import (
	_ "embed"
	"encoding/binary"

	"github.com/alecthomas/mph"

	yosina "github.com/yosina-lib/yosina/go"
)

//go:embed data.bin
var data []byte

var mapping *mph.CHD

func init() {
	var err error
	mapping, err = mph.Mmap(data)
	if err != nil {
		panic(err)
	}
}

type combinedCharIterator struct {
	yosina.CharIterator
	offset int
	queue  []rune
	source *yosina.Char
}

func (i *combinedCharIterator) Next() *yosina.Char {
	// If we have queued characters from a previous expansion, return them first
	if len(i.queue) > 0 {
		c := i.queue[0]
		i.queue = i.queue[1:]
		char := &yosina.Char{
			C:      [2]rune{c, yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: i.source,
		}
		i.offset += char.RuneLen()
		return char
	}

	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	if c.IsSentinel() {
		return c
	}

	// Check if current character can be transliterated
	var k [8]byte
	binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
	binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))
	if v := mapping.Get(k[:]); v != nil {
		// Decode the character array from the value
		if len(v) < 5 {
			// Invalid data, return original character
			return c.WithOffset(i.offset)
		}
		
		numChars := binary.LittleEndian.Uint32(v[:4])
		chars := make([]rune, 0, numChars)
		
		// Each character is stored as 4 bytes (UTF-32)
		for j := uint32(0); j < numChars && int(4+j*4+4) <= len(v); j++ {
			charCode := binary.LittleEndian.Uint32(v[4+j*4:])
			chars = append(chars, rune(charCode))
		}
		
		if len(chars) == 0 {
			// No replacement characters, return original
			return c.WithOffset(i.offset)
		}
		
		// Store the source for all subsequent characters
		i.source = c
		
		// Return the first character immediately
		firstChar := &yosina.Char{
			C:      [2]rune{chars[0], yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: c,
		}
		i.offset += firstChar.RuneLen()
		
		// Queue the remaining characters
		if len(chars) > 1 {
			i.queue = chars[1:]
		}
		
		return firstChar
	} else {
		char := c.WithOffset(i.offset)
		i.offset += char.RuneLen()
		return char
	}
}

func Transliterate(i yosina.CharIterator) yosina.CharIterator {
	return &combinedCharIterator{CharIterator: i, offset: 0}
}
`

func (em *Emitter) GenerateCombinedTransliterator(name string, mappings map[data.UCodepoint][]string) ([]Artifact, error) {
	tmpl, err := template.New("combined").Parse(combinedTransliteratorTemplate)
	if err != nil {
		return nil, err
	}

	var buf strings.Builder
	err = tmpl.Execute(&buf, map[string]interface{}{
		"Name": name,
	})
	if err != nil {
		return nil, err
	}

	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format Go source: %w", err)
	}

	// Generate binary data for the mappings
	binaryData, err := generateCombinedBinaryData(mappings)
	if err != nil {
		return nil, fmt.Errorf("failed to generate binary data: %w", err)
	}

	return []Artifact{
		{
			Filename: name + "/impl.go",
			Content:  formatted,
		},
		{
			Filename: name + "/data.bin",
			Content:  binaryData,
		},
	}, nil
}

func generateCombinedBinaryData(mappings map[data.UCodepoint][]string) ([]byte, error) {
	// Build the perfect hash table using the mph.Builder pattern
	b := mph.Builder()

	for char, charList := range mappings {
		// Create key (8 bytes for UCodepoint tuple)
		key := make([]byte, 8)
		binary.LittleEndian.PutUint32(key[:4], uint32(char))
		binary.LittleEndian.PutUint32(key[4:], uint32(data.InvalidValue)) // Second rune is invalid for single chars

		// Create value (4 bytes for count + 4 bytes per character)
		value := make([]byte, 4+len(charList)*4)
		binary.LittleEndian.PutUint32(value[:4], uint32(len(charList)))

		for i, charStr := range charList {
			if len(charStr) > 0 {
				// Take the first rune of the string
				runes := []rune(charStr)
				binary.LittleEndian.PutUint32(value[4+i*4:], uint32(runes[0]))
			}
		}

		b.Add(key, value)
	}

	// Build the perfect hash table
	table, err := b.Build()
	if err != nil {
		return nil, fmt.Errorf("failed to build perfect hash table: %w", err)
	}

	// Serialize to bytes
	var buf bytes.Buffer
	if err := table.Write(&buf); err != nil {
		return nil, fmt.Errorf("failed to serialize hash table: %w", err)
	}

	return buf.Bytes(), nil
}
