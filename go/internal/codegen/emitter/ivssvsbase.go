package emitter

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"go/format"
	"path"
	"strings"
	"text/template"

	"github.com/alecthomas/mph"
	"github.com/yosina-lib/yosina/go/internal/codegen/data"
)

// Templates for IVS/SVS base transliterator
const ivsSvsBaseTransliteratorTemplate = `// Code generated by codegen. DO NOT EDIT.
package {{.Name}}

import (
	_ "embed"
	"encoding/binary"
	"fmt"

	"github.com/alecthomas/mph"

	yosina "github.com/yosina-lib/yosina/go"
)

//go:embed data.bin
var data []byte

var offsets = [3]int{
	{{range $i, $offset := .Offsets}}
		{{$offset}},
	{{end}}
}

var mappings [3]*mph.CHD

func init() {
	for i := range offsets {
		s := offsets[i]
		var e int
		if i+1 < len(offsets) {
			e = offsets[i+1]
		} else {
		 	e = len(data)
		}
		mapping, err := mph.Mmap(data[s:e])
		if err != nil {
			panic(err)
		}
		mappings[i] = mapping
	}
}

type IvsSvsBaseRecord struct {
	IVS      [2]rune
	SVS      [2]rune
	Base90   rune
	Base2004 rune
}

type Mode string

const (
	ModeIvsOrSvs Mode = "ivs-or-svs"
	ModeBase     Mode = "base"
)

type Charset int

const (
	CharsetUnijis90   Charset = iota + 1
	CharsetUnijis2004
)

type Options struct {
	Mode                     Mode
	DropSelectorsAltogether  bool
	Charset                  Charset
	PreferSvs                bool
}

var DefaultOptions = Options{
	Mode:                     ModeBase,
	DropSelectorsAltogether:  false,
	Charset:                  CharsetUnijis2004,
	PreferSvs:                false,
}

func decodeIvsSvsBaseRecord(data []byte) *IvsSvsBaseRecord {
	record := &IvsSvsBaseRecord{}
	offset := 0
	
	// IVS (8 bytes - 2 runes)
	if len(data) >= offset+8 {
		record.IVS[0] = rune(binary.LittleEndian.Uint32(data[offset:]))
		record.IVS[1] = rune(binary.LittleEndian.Uint32(data[offset+4:]))
		offset += 8
	}
	
	// SVS (8 bytes - 2 runes)
	if len(data) >= offset+8 {
		record.SVS[0] = rune(binary.LittleEndian.Uint32(data[offset:]))
		record.SVS[1] = rune(binary.LittleEndian.Uint32(data[offset+4:]))
		offset += 8
	}
	
	// Base90 (4 bytes)
	if len(data) >= offset+4 {
		record.Base90 = rune(binary.LittleEndian.Uint32(data[offset:]))
		offset += 4
	}
	
	// Base2004 (4 bytes)
	if len(data) >= offset+4 {
		record.Base2004 = rune(binary.LittleEndian.Uint32(data[offset:]))
		offset += 4
	}
	
	return record
}

type ivsSvsBaseFwdCharIterator struct {
	yosina.CharIterator
	options Options
	offset  int
}

func (i *ivsSvsBaseFwdCharIterator) Next() *yosina.Char {
	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	if c.IsSentinel() {
		return c
	} 
	
	var r *IvsSvsBaseRecord
	if c.C[1] != yosina.InvalidUnicodeValue {
		var k [8]byte
		binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
		binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))

		if v := mappings[0].Get(k[:]); v != nil {
			r = decodeIvsSvsBaseRecord(v)
		}
	} else {
		var k [4]byte
		binary.LittleEndian.PutUint32(k[:], uint32(c.C[0]))
		if v := mappings[i.options.Charset].Get(k[:]); v != nil {
			r = decodeIvsSvsBaseRecord(v)
		}
	}
	if r != nil {
		var cc [2]rune
		if i.options.PreferSvs {
			if r.SVS[0] != yosina.InvalidUnicodeValue {
				cc = r.SVS
			} else if r.IVS[0] != yosina.InvalidUnicodeValue {
				cc = r.IVS
			}
		} else {
			if r.IVS[0] != yosina.InvalidUnicodeValue {
				cc = r.IVS
			} else if r.SVS[0] != yosina.InvalidUnicodeValue {
				cc = r.SVS
			}
		}
		c = &yosina.Char{
			C: cc,
			Offset: i.offset,
			Source: c,
		}
	} else {
		c = c.WithOffset(i.offset)
	}
	i.offset += c.RuneLen()
	return c
}

type ivsSvsBaseRevCharIterator struct {
	yosina.CharIterator
	options Options
	offset  int
}

func (i *ivsSvsBaseRevCharIterator) Next() *yosina.Char {
	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	if c.IsSentinel() {
		return c
	}

	var r *IvsSvsBaseRecord
	if c.C[1] != yosina.InvalidUnicodeValue {
		var k [8]byte
		binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
		binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))

		if v := mappings[0].Get(k[:]); v != nil {
			r = decodeIvsSvsBaseRecord(v)
		}
	}
	if r != nil {
		var cc [2]rune
		cc[0] = yosina.InvalidUnicodeValue
		switch i.options.Charset {
		case CharsetUnijis90:
			cc = [2]rune{r.Base90, yosina.InvalidUnicodeValue}
		case CharsetUnijis2004:
			cc = [2]rune{r.Base2004, yosina.InvalidUnicodeValue}
		}
		if cc[0] != yosina.InvalidUnicodeValue {
			c = &yosina.Char{
				C: cc,
				Offset: i.offset,
				Source: c,
			}
			i.offset += c.RuneLen()
			return c
		}
	}
	if i.options.DropSelectorsAltogether {
		c = &yosina.Char{
			C: [2]rune{c.C[0], yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: c,
		}
		i.offset += c.RuneLen()
		return c
	}
	c = c.WithOffset(i.offset)
	i.offset += c.RuneLen()
	return c
}

func Transliterate(i yosina.CharIterator, opts ...Options) yosina.CharIterator {
	options := DefaultOptions
	if len(opts) > 0 {
		options = opts[0]
	}
	switch options.Mode {
	case ModeIvsOrSvs:
		return &ivsSvsBaseFwdCharIterator{
			CharIterator: i,
			options:      options,
			offset:	      0,
		}
	case ModeBase:
		return &ivsSvsBaseRevCharIterator{
			CharIterator: i,
			options:      options,
			offset:	      0,
		}
	default:
		panic(fmt.Errorf("unknown mode: %s", options.Mode))
	}
}
`

func (em *Emitter) GenerateIvsSvsBaseTransliterator(name string, records []data.IvsSvsBaseRecord) ([]Artifact, error) {
	// Build the minimal perfect hash for the data
	b := []*mph.CHDBuilder{
		mph.Builder(),
		mph.Builder(),
		mph.Builder(),
	}
	a0 := make(map[[8]byte]bool)
	a1 := make(map[[4]byte]bool)
	a2 := make(map[[4]byte]bool)

	for _, record := range records {
		var buf [24]byte
		value := encodeIvsSvsBaseRecord(buf[:0], record)

		// Create keys for both IVS and SVS sequences
		if record.IVS[0] != data.InvalidValue {
			var k [8]byte
			binary.LittleEndian.PutUint32(k[:4], uint32(record.IVS[0]))
			binary.LittleEndian.PutUint32(k[4:], uint32(record.IVS[1]))
			if !a0[k] {
				b[0].Add(k[:], value)
				a0[k] = true
			}
		}

		if record.SVS[0] != data.InvalidValue {
			var k [8]byte
			binary.LittleEndian.PutUint32(k[:4], uint32(record.SVS[0]))
			binary.LittleEndian.PutUint32(k[4:], uint32(record.SVS[1]))
			if !a0[k] {
				b[0].Add(k[:], value)
				a0[k] = true
			}
		}

		// Also add base character keys for reverse lookup
		if record.Base90 != data.InvalidValue {
			var k [4]byte
			binary.LittleEndian.PutUint32(k[:], uint32(record.Base90))
			if !a1[k] {
				b[1].Add(k[:], value)
				a1[k] = true
			}
		}

		if record.Base2004 != data.InvalidValue {
			var k [4]byte
			binary.LittleEndian.PutUint32(k[:], uint32(record.Base2004))
			if !a2[k] {
				b[2].Add(k[:], value)
				a2[k] = true
			}
		}
	}

	offsets := make([]int, len(b))
	var bb bytes.Buffer
	for i, b_ := range b {
		c, err := b_.Build()
		if err != nil {
			return nil, fmt.Errorf("failed to build mph: %w", err)
		}
		offsets[i] = bb.Len()
		c.Write(&bb)
	}

	// Generate the implementation code
	tmpl, err := template.New("ivssvsbase").Parse(ivsSvsBaseTransliteratorTemplate)
	if err != nil {
		return nil, err
	}

	var buf strings.Builder
	err = tmpl.Execute(&buf, map[string]interface{}{
		"Name":    name,
		"Offsets": offsets,
	})
	if err != nil {
		return nil, err
	}

	// Format the generated code
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w", err)
	}

	return []Artifact{
		{
			Filename: path.Join(name, "impl.go"),
			Content:  formatted,
		},
		{
			Filename: path.Join(name, "data.bin"),
			Content:  bb.Bytes(),
		},
	}, nil
}

func encodeIvsSvsBaseRecord(buf []byte, record data.IvsSvsBaseRecord) []byte {
	// IVS (8 bytes - 2 runes)
	buf = binary.LittleEndian.AppendUint32(buf, uint32(record.IVS[0]))
	buf = binary.LittleEndian.AppendUint32(buf, uint32(record.IVS[1]))

	// SVS (8 bytes - 2 runes)
	buf = binary.LittleEndian.AppendUint32(buf, uint32(record.SVS[0]))
	buf = binary.LittleEndian.AppendUint32(buf, uint32(record.SVS[1]))

	// Base90 (4 bytes)
	buf = binary.LittleEndian.AppendUint32(buf, uint32(record.Base90))

	// Base2004 (4 bytes)
	buf = binary.LittleEndian.AppendUint32(buf, uint32(record.Base2004))

	return buf
}
