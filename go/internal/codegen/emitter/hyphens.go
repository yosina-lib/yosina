package emitter

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"go/format"
	"path"
	"strings"
	"text/template"

	"github.com/alecthomas/mph"
	yosina "github.com/yosina-lib/yosina/go"
	"github.com/yosina-lib/yosina/go/internal/codegen/data"
)

// Templates for hyphens transliterator
const hyphensTransliteratorTemplate = `// Code generated by codegen. DO NOT EDIT.
package {{.Name}}

import (
	_ "embed"
	"encoding/binary"

	"github.com/alecthomas/mph"

	yosina "github.com/yosina-lib/yosina/go"
)

//go:embed data.bin
var data []byte

var mapping *mph.CHD

func init() {
	var err error
	mapping, err = mph.Mmap(data)
	if err != nil {
		panic(err)
	}
}

type HyphensRecord [5][4]rune

type Mapping int

const (
	ASCII Mapping = iota
	Jisx0201
	Jisx0208_90
	Jisx0208_90_Windows
	Jisx0208_Verbatim
)

var DefaultPrecedence = []Mapping{Jisx0208_90}

type Options struct {
	Precedence []Mapping
}

type hyphensCharIterator struct {
	yosina.CharIterator
	precedence []Mapping
	offset     int
	c		   *yosina.Char
	buf        *[4]rune
	bufOffset  int
}

func (i *hyphensCharIterator) Next() *yosina.Char {
	if i.buf != nil {
		if i.buf[i.bufOffset] != yosina.InvalidUnicodeValue {
			// Return buffered character
			cc := &yosina.Char{
				C:      [2]rune{i.buf[i.bufOffset], yosina.InvalidUnicodeValue},
				Offset: i.offset,
				Source: i.c,
			}
			i.bufOffset += 1
			i.offset += cc.RuneLen()
			return cc
		} else {
		 	i.buf = nil
		}
	}

	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	
	// Build key for lookup
	var k [8]byte
	binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
	binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))
	
	if v := mapping.Get(k[:]); v != nil {
		record := decodeHyphensRecord(v)
		if r := i.getReplacement(record); r != nil {
			i.buf = r
			i.c = c
			i.bufOffset = 1
			cc := &yosina.Char{
				C: [2]rune{r[0], yosina.InvalidUnicodeValue},
				Offset: i.offset,
				Source: c,
			}
			i.offset += cc.RuneLen()
			return cc
		}
	}
	return c
}

func (i *hyphensCharIterator) getReplacement(record *HyphensRecord) *[4]rune {
	for _, m := range i.precedence {
		if record[m][0] != yosina.InvalidUnicodeValue {
			return &record[m]
		}
	}
	return nil
}

func decodeHyphensRecord(data []byte) *HyphensRecord {
	record := &HyphensRecord{}
	offset := 0

	// ASCII length (4 bytes) + data
	for i := 0; i < 4; i++ {
		record[ASCII][i] = rune(binary.LittleEndian.Uint32(data[offset:]))
		offset += 4
	}
	
	// Jisx0201 length (4 bytes) + data
	for i := 0; i < 4; i++ {
		record[Jisx0201][i] = rune(binary.LittleEndian.Uint32(data[offset:]))
		offset += 4
	}
	
	// Jisx0208_90 length (4 bytes) + data
	for i := 0; i < 4; i++ {
		record[Jisx0208_90][i] = rune(binary.LittleEndian.Uint32(data[offset:]))
		offset += 4
	}
	
	// Jisx0208_90_Windows length (4 bytes) + data
	for i := 0; i < 4; i++ {
		record[Jisx0208_90_Windows][i] = rune(binary.LittleEndian.Uint32(data[offset:]))
		offset += 4
	}
	
	// Jisx0208_Verbatim (4 bytes)
	for i := 0; i < 4; i++ {
		record[Jisx0208_Verbatim][i] = rune(binary.LittleEndian.Uint32(data[offset:]))
		offset += 4
	}
	
	return record
}

func Transliterate(i yosina.CharIterator, opts Options) yosina.CharIterator {
	precedence := DefaultPrecedence
	if len(opts.Precedence) > 0 {
		precedence = opts.Precedence
	}
	return &hyphensCharIterator{
		CharIterator: i,
		precedence:   precedence,
		offset:	      0,
	}
}
`

func (em *Emitter) GenerateHyphensTransliterator(name string, records []data.HyphensRecord) ([]Artifact, error) {
	// Generate the implementation code
	tmpl, err := template.New("hyphens").Parse(hyphensTransliteratorTemplate)
	if err != nil {
		return nil, err
	}

	var buf strings.Builder
	err = tmpl.Execute(&buf, map[string]interface{}{
		"Name": name,
	})
	if err != nil {
		return nil, err
	}

	// Format the generated code
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w", err)
	}

	// Build the minimal perfect hash for the data
	b := mph.Builder()
	for _, record := range records {
		var bb [88]byte
		binary.LittleEndian.PutUint32(bb[:4], uint32(record.Code))
		binary.LittleEndian.PutUint32(bb[4:], uint32(yosina.InvalidUnicodeValue))
		k := bb[:8]
		v := encodeHyphensRecord(bb[8:8], record)
		b.Add(k, v)
	}

	mph_data, err := b.Build()
	if err != nil {
		return nil, fmt.Errorf("failed to build mph: %w", err)
	}

	var bb bytes.Buffer
	mph_data.Write(&bb)

	return []Artifact{
		{
			Filename: path.Join(name, "impl.go"),
			Content:  formatted,
		},
		{
			Filename: path.Join(name, "data.bin"),
			Content:  bb.Bytes(),
		},
	}, nil
}

func encodeHyphensRecord(buf []byte, record data.HyphensRecord) []byte {
	// ASCII data
	for _, r := range record.ASCII {
		buf = binary.LittleEndian.AppendUint32(buf, uint32(r))
	}
	for i := len(record.ASCII); i < 4; i++ {
		buf = binary.LittleEndian.AppendUint32(buf, uint32(yosina.InvalidUnicodeValue))
	}

	// Jisx0201 length + data
	for _, r := range record.Jisx0201 {
		buf = binary.LittleEndian.AppendUint32(buf, uint32(r))
	}
	for i := len(record.Jisx0201); i < 4; i++ {
		buf = binary.LittleEndian.AppendUint32(buf, uint32(yosina.InvalidUnicodeValue))
	}

	// Jisx0208_90 length + data
	for _, r := range record.Jisx0208_90 {
		buf = binary.LittleEndian.AppendUint32(buf, uint32(r))
	}
	for i := len(record.Jisx0208_90); i < 4; i++ {
		buf = binary.LittleEndian.AppendUint32(buf, uint32(yosina.InvalidUnicodeValue))
	}

	// Jisx0208_90_Windows length + data
	for _, r := range record.Jisx0208_90_Windows {
		buf = binary.LittleEndian.AppendUint32(buf, uint32(r))
	}
	for i := len(record.Jisx0208_90_Windows); i < 4; i++ {
		buf = binary.LittleEndian.AppendUint32(buf, uint32(yosina.InvalidUnicodeValue))
	}

	// Jisx0208_Verbatim (4 bytes)
	buf = binary.LittleEndian.AppendUint32(buf, uint32(record.Jisx0208_Verbatim))
	for i := 1; i < 4; i++ {
		buf = binary.LittleEndian.AppendUint32(buf, uint32(yosina.InvalidUnicodeValue))
	}
	return buf
}
