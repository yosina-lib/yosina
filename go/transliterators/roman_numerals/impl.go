// Code generated by codegen. DO NOT EDIT.
package roman_numerals

import (
	_ "embed"
	"encoding/binary"

	"github.com/alecthomas/mph"

	yosina "github.com/yosina-lib/yosina/go"
)

//go:embed data.bin
var data []byte

var mapping *mph.CHD

func init() {
	var err error
	mapping, err = mph.Mmap(data)
	if err != nil {
		panic(err)
	}
}

type combinedCharIterator struct {
	yosina.CharIterator
	offset int
	queue  []rune
	source *yosina.Char
}

func (i *combinedCharIterator) Next() *yosina.Char {
	// If we have queued characters from a previous expansion, return them first
	if len(i.queue) > 0 {
		c := i.queue[0]
		i.queue = i.queue[1:]
		char := &yosina.Char{
			C:      [2]rune{c, yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: i.source,
		}
		i.offset += char.RuneLen()
		return char
	}

	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	if c.IsSentinel() {
		return c
	}

	// Check if current character can be transliterated
	var k [8]byte
	binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
	binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))
	if v := mapping.Get(k[:]); v != nil {
		// Decode the character array from the value
		if len(v) < 5 {
			// Invalid data, return original character
			return c.WithOffset(i.offset)
		}

		numChars := binary.LittleEndian.Uint32(v[:4])
		chars := make([]rune, 0, numChars)

		// Each character is stored as 4 bytes (UTF-32)
		for j := uint32(0); j < numChars && int(4+j*4+4) <= len(v); j++ {
			charCode := binary.LittleEndian.Uint32(v[4+j*4:])
			chars = append(chars, rune(charCode))
		}

		if len(chars) == 0 {
			// No replacement characters, return original
			return c.WithOffset(i.offset)
		}

		// Store the source for all subsequent characters
		i.source = c

		// Return the first character immediately
		firstChar := &yosina.Char{
			C:      [2]rune{chars[0], yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: c,
		}
		i.offset += firstChar.RuneLen()

		// Queue the remaining characters
		if len(chars) > 1 {
			i.queue = chars[1:]
		}

		return firstChar
	} else {
		char := c.WithOffset(i.offset)
		i.offset += char.RuneLen()
		return char
	}
}

func Transliterate(i yosina.CharIterator) yosina.CharIterator {
	return &combinedCharIterator{CharIterator: i, offset: 0}
}
