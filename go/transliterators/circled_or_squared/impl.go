// Code generated by codegen. DO NOT EDIT.
package circled_or_squared

import (
	_ "embed"
	"encoding/binary"
	"strings"

	"github.com/alecthomas/mph"

	yosina "github.com/yosina-lib/yosina/go"
)

//go:embed data.bin
var data []byte

var mapping *mph.CHD

func init() {
	var err error
	mapping, err = mph.Mmap(data)
	if err != nil {
		panic(err)
	}
}

// Options for the circled or squared transliterator
type Options struct {
	TemplateForCircled string
	TemplateForSquared string
	IncludeEmojis      bool
}

type circledOrSquaredCharIterator struct {
	yosina.CharIterator
	offset  int
	queue   []rune
	source  *yosina.Char
	options Options
}

func (i *circledOrSquaredCharIterator) Next() *yosina.Char {
	// If we have queued characters from a previous expansion, return them first
	if len(i.queue) > 0 {
		c := i.queue[0]
		i.queue = i.queue[1:]
		char := &yosina.Char{
			C:      [2]rune{c, yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: i.source,
		}
		i.offset += char.RuneLen()
		return char
	}

	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	if c.IsSentinel() {
		return c
	}

	// Check if current character can be transliterated
	var k [8]byte
	binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
	binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))
	if v := mapping.Get(k[:]); v != nil {
		// Decode the record from the value
		if len(v) < 5 {
			// Invalid data, return original character
			return c.WithOffset(i.offset)
		}

		renderingLen := int(v[0] & 0xf)
		typeCode := v[0] & 0x10
		isEmoji := v[0]&0x20 != 0

		// Skip emoji characters if not included
		if isEmoji && !i.options.IncludeEmojis {
			char := c.WithOffset(i.offset)
			i.offset += char.RuneLen()
			return char
		}

		// Extract rendering string (UTF-32 encoded)
		var r strings.Builder
		for j := 0; j < renderingLen; j++ {
			r.WriteRune(rune(binary.LittleEndian.Uint32(v[1+j*4:])))
		}
		rendering := r.String()

		// Determine template
		var template string
		if typeCode == 0 { // circle
			template = i.options.TemplateForCircled
		} else { // square
			template = i.options.TemplateForSquared
		}

		// Apply template
		replacement := strings.ReplaceAll(template, "?", rendering)
		replacementRunes := []rune(replacement)

		if len(replacementRunes) == 0 {
			// No replacement, return original
			char := c.WithOffset(i.offset)
			i.offset += char.RuneLen()
			return char
		}

		// Store the source for all subsequent characters
		i.source = c

		// Return the first character immediately
		firstChar := &yosina.Char{
			C:      [2]rune{replacementRunes[0], yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: c,
		}
		i.offset += firstChar.RuneLen()

		// Queue the remaining characters
		if len(replacementRunes) > 1 {
			i.queue = replacementRunes[1:]
		}

		return firstChar
	} else {
		char := c.WithOffset(i.offset)
		i.offset += char.RuneLen()
		return char
	}
}

func Transliterate(i yosina.CharIterator, options Options) yosina.CharIterator {
	if options.TemplateForCircled == "" {
		options.TemplateForCircled = "(?)"
	}
	if options.TemplateForSquared == "" {
		options.TemplateForSquared = "[?]"
	}
	return &circledOrSquaredCharIterator{CharIterator: i, offset: 0, options: options}
}
