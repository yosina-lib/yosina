// Code generated by codegen. DO NOT EDIT.
package ivs_svs_base

import (
	_ "embed"
	"encoding/binary"
	"fmt"

	"github.com/alecthomas/mph"

	yosina "github.com/yosina-lib/yosina/go"
)

//go:embed data.bin
var data []byte

var offsets = [3]int{

	0,

	606636,

	1106182,
}

var mappings [3]*mph.CHD

func init() {
	for i := range offsets {
		s := offsets[i]
		var e int
		if i+1 < len(offsets) {
			e = offsets[i+1]
		} else {
			e = len(data)
		}
		mapping, err := mph.Mmap(data[s:e])
		if err != nil {
			panic(err)
		}
		mappings[i] = mapping
	}
}

type IvsSvsBaseRecord struct {
	IVS      [2]rune
	SVS      [2]rune
	Base90   rune
	Base2004 rune
}

type Mode string

const (
	ModeIvsOrSvs Mode = "ivs-or-svs"
	ModeBase     Mode = "base"
)

type Charset int

const (
	CharsetUnijis90 Charset = iota + 1
	CharsetUnijis2004
)

type Options struct {
	Mode                    Mode
	DropSelectorsAltogether bool
	Charset                 Charset
	PreferSvs               bool
}

var DefaultOptions = Options{
	Mode:                    ModeBase,
	DropSelectorsAltogether: false,
	Charset:                 CharsetUnijis2004,
	PreferSvs:               false,
}

func decodeIvsSvsBaseRecord(data []byte) *IvsSvsBaseRecord {
	record := &IvsSvsBaseRecord{}
	offset := 0

	// IVS (8 bytes - 2 runes)
	if len(data) >= offset+8 {
		record.IVS[0] = rune(binary.LittleEndian.Uint32(data[offset:]))
		record.IVS[1] = rune(binary.LittleEndian.Uint32(data[offset+4:]))
		offset += 8
	}

	// SVS (8 bytes - 2 runes)
	if len(data) >= offset+8 {
		record.SVS[0] = rune(binary.LittleEndian.Uint32(data[offset:]))
		record.SVS[1] = rune(binary.LittleEndian.Uint32(data[offset+4:]))
		offset += 8
	}

	// Base90 (4 bytes)
	if len(data) >= offset+4 {
		record.Base90 = rune(binary.LittleEndian.Uint32(data[offset:]))
		offset += 4
	}

	// Base2004 (4 bytes)
	if len(data) >= offset+4 {
		record.Base2004 = rune(binary.LittleEndian.Uint32(data[offset:]))
		offset += 4
	}

	return record
}

type ivsSvsBaseFwdCharIterator struct {
	yosina.CharIterator
	options Options
	offset  int
}

func (i *ivsSvsBaseFwdCharIterator) Next() *yosina.Char {
	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	if c.IsSentinel() {
		return c
	}

	var r *IvsSvsBaseRecord
	if c.C[1] != yosina.InvalidUnicodeValue {
		var k [8]byte
		binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
		binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))

		if v := mappings[0].Get(k[:]); v != nil {
			r = decodeIvsSvsBaseRecord(v)
		}
	} else {
		var k [4]byte
		binary.LittleEndian.PutUint32(k[:], uint32(c.C[0]))
		if v := mappings[i.options.Charset].Get(k[:]); v != nil {
			r = decodeIvsSvsBaseRecord(v)
		}
	}
	if r != nil {
		var cc [2]rune
		if i.options.PreferSvs {
			if r.SVS[0] != yosina.InvalidUnicodeValue {
				cc = r.SVS
			} else if r.IVS[0] != yosina.InvalidUnicodeValue {
				cc = r.IVS
			}
		} else {
			if r.IVS[0] != yosina.InvalidUnicodeValue {
				cc = r.IVS
			} else if r.SVS[0] != yosina.InvalidUnicodeValue {
				cc = r.SVS
			}
		}
		c = &yosina.Char{
			C:      cc,
			Offset: i.offset,
			Source: c,
		}
	} else {
		c = c.WithOffset(i.offset)
	}
	i.offset += c.RuneLen()
	return c
}

type ivsSvsBaseRevCharIterator struct {
	yosina.CharIterator
	options Options
	offset  int
}

func (i *ivsSvsBaseRevCharIterator) Next() *yosina.Char {
	c := i.CharIterator.Next()
	if c == nil {
		return nil
	}
	if c.IsSentinel() {
		return c
	}

	var r *IvsSvsBaseRecord
	if c.C[1] != yosina.InvalidUnicodeValue {
		var k [8]byte
		binary.LittleEndian.PutUint32(k[:4], uint32(c.C[0]))
		binary.LittleEndian.PutUint32(k[4:], uint32(c.C[1]))

		if v := mappings[0].Get(k[:]); v != nil {
			r = decodeIvsSvsBaseRecord(v)
		}
	}
	if r != nil {
		var cc [2]rune
		cc[0] = yosina.InvalidUnicodeValue
		switch i.options.Charset {
		case CharsetUnijis90:
			cc = [2]rune{r.Base90, yosina.InvalidUnicodeValue}
		case CharsetUnijis2004:
			cc = [2]rune{r.Base2004, yosina.InvalidUnicodeValue}
		}
		if cc[0] != yosina.InvalidUnicodeValue {
			c = &yosina.Char{
				C:      cc,
				Offset: i.offset,
				Source: c,
			}
			i.offset += c.RuneLen()
			return c
		}
	}
	if i.options.DropSelectorsAltogether {
		c = &yosina.Char{
			C:      [2]rune{c.C[0], yosina.InvalidUnicodeValue},
			Offset: i.offset,
			Source: c,
		}
		i.offset += c.RuneLen()
		return c
	}
	c = c.WithOffset(i.offset)
	i.offset += c.RuneLen()
	return c
}

func Transliterate(i yosina.CharIterator, opts ...Options) yosina.CharIterator {
	options := DefaultOptions
	if len(opts) > 0 {
		options = opts[0]
	}
	switch options.Mode {
	case ModeIvsOrSvs:
		return &ivsSvsBaseFwdCharIterator{
			CharIterator: i,
			options:      options,
			offset:       0,
		}
	case ModeBase:
		return &ivsSvsBaseRevCharIterator{
			CharIterator: i,
			options:      options,
			offset:       0,
		}
	default:
		panic(fmt.Errorf("unknown mode: %s", options.Mode))
	}
}
