import 'chained_transliterator.dart';
import 'char.dart';
import 'transliteration_recipe.dart';
import 'transliterator_registry.dart';

/// Configuration for a single transliterator.
class TransliteratorConfig {
  /// Creates a transliterator configuration.
  ///
  /// - [name] is the identifier of the transliterator to use
  /// - [options] is an optional map of configuration options specific to the transliterator
  const TransliteratorConfig(this.name, [this.options = const {}]);

  /// Creates a transliterator configuration from a map representation.
  ///
  /// The map must contain a 'name' key with a string value.
  /// It may optionally contain an 'options' key with a map of configuration options.
  factory TransliteratorConfig.fromMap(Map<String, dynamic> map) {
    return TransliteratorConfig(
      map['name'] as String,
      (map['options'] as Map<String, dynamic>?) ?? const {},
    );
  }

  /// The name/identifier of the transliterator.
  final String name;
  
  /// Configuration options specific to this transliterator.
  final Map<String, dynamic> options;
}

/// Base interface for all transliterators.
///
/// A transliterator transforms a sequence of characters according to specific
/// rules. Implementations may perform various transformations such as script
/// conversions, normalization, or character substitutions.
abstract class Transliterator {
  /// Transforms the input characters.
  ///
  /// Takes an iterable of [Char] objects and returns a transformed iterable.
  /// The transformation applied depends on the specific transliterator implementation.
  Iterable<Char> call(Iterable<Char> inputChars);

  /// Creates a transliterator from a list of transliterator names.
  ///
  /// - [names] is a list of transliterator identifiers to chain together
  /// - [registry] is an optional custom registry (defaults to the global registry)
  ///
  /// Returns a single transliterator if only one name is provided,
  /// or a [ChainedTransliterator] if multiple names are provided.
  static Transliterator withList(List<String> names,
      [TransliteratorRegistry? registry]) {
    registry ??= TransliteratorRegistry.defaultRegistry;
    final configs = names.map((name) => TransliteratorConfig(name)).toList();
    return withConfigs(configs, registry);
  }

  /// Creates a transliterator from a list of configuration maps.
  ///
  /// Each map in [configMaps] must contain a 'name' key and may optionally
  /// contain an 'options' key with configuration parameters.
  ///
  /// - [configMaps] is a list of configuration maps
  /// - [registry] is an optional custom registry (defaults to the global registry)
  static Transliterator withMap(List<Map<String, dynamic>> configMaps,
      [TransliteratorRegistry? registry]) {
    registry ??= TransliteratorRegistry.defaultRegistry;
    final configs = configMaps
        .map((config) => TransliteratorConfig.fromMap(config))
        .toList();
    return withConfigs(configs, registry);
  }

  /// Creates a transliterator from a list of configurations.
  ///
  /// - [configs] is a list of [TransliteratorConfig] objects
  /// - [registry] is an optional custom registry (defaults to the global registry)
  ///
  /// Returns a single transliterator if only one config is provided,
  /// or a [ChainedTransliterator] if multiple configs are provided.
  ///
  /// Throws [ArgumentError] if configs is empty.
  static Transliterator withConfigs(List<TransliteratorConfig> configs,
      [TransliteratorRegistry? registry]) {
    final reg = registry ?? TransliteratorRegistry.defaultRegistry;

    if (configs.isEmpty) {
      throw ArgumentError(
          'Configs must contain at least one transliterator config');
    }

    if (configs.length == 1) {
      return reg.create(configs[0].name, configs[0].options);
    }

    final transliterators = configs
        .map((config) => reg.create(config.name, config.options))
        .toList();

    return ChainedTransliterator(transliterators);
  }

  /// Creates a transliterator from a recipe.
  ///
  /// A recipe encapsulates a predefined set of transliterator configurations
  /// for common use cases.
  ///
  /// - [recipe] is the transliteration recipe to use
  /// - [registry] is an optional custom registry (defaults to the global registry)
  static Transliterator withRecipe(TransliterationRecipe recipe,
      [TransliteratorRegistry? registry]) {
    return withConfigs(recipe.buildTransliteratorConfigs(), registry);
  }
}
